{"version":3,"names":["_gesture","require","HoverEffect","hoverGestureHandlerProps","changeEventCalculator","current","previous","changePayload","undefined","changeX","x","changeY","y","Object","assign","HoverGesture","_gesture$ContinousBas","_this","_classCallCheck2","default","_callSuper","_defineProperty","handlerName","_inherits2","_createClass2","key","value","effect","config","hoverEffect","onChange","callback","handlers","_get2","_getPrototypeOf2","prototype","call","ContinousBaseGesture"],"sources":["hoverGesture.ts"],"sourcesContent":["import { BaseGestureConfig, ContinousBaseGesture } from './gesture';\nimport { GestureUpdateEvent } from '../gestureHandlerCommon';\n\nexport type HoverGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport type HoverGestureChangeEventPayload = {\n  changeX: number;\n  changeY: number;\n};\n\nexport enum HoverEffect {\n  NONE = 0,\n  LIFT = 1,\n  HIGHLIGHT = 2,\n}\n\nexport interface HoverGestureConfig {\n  hoverEffect?: HoverEffect;\n}\n\nexport const hoverGestureHandlerProps = ['hoverEffect'] as const;\n\nfunction changeEventCalculator(\n  current: GestureUpdateEvent<HoverGestureHandlerEventPayload>,\n  previous?: GestureUpdateEvent<HoverGestureHandlerEventPayload>\n) {\n  'worklet';\n  let changePayload: HoverGestureChangeEventPayload;\n  if (previous === undefined) {\n    changePayload = {\n      changeX: current.x,\n      changeY: current.y,\n    };\n  } else {\n    changePayload = {\n      changeX: current.x - previous.x,\n      changeY: current.y - previous.y,\n    };\n  }\n\n  return { ...current, ...changePayload };\n}\n\nexport class HoverGesture extends ContinousBaseGesture<\n  HoverGestureHandlerEventPayload,\n  HoverGestureChangeEventPayload\n> {\n  public config: BaseGestureConfig & HoverGestureConfig = {};\n\n  constructor() {\n    super();\n\n    this.handlerName = 'HoverGestureHandler';\n  }\n\n  /**\n   * Sets the visual hover effect.\n   * iOS only\n   */\n  effect(effect: HoverEffect) {\n    this.config.hoverEffect = effect;\n    return this;\n  }\n\n  onChange(\n    callback: (\n      event: GestureUpdateEvent<\n        HoverGestureHandlerEventPayload & HoverGestureChangeEventPayload\n      >\n    ) => void\n  ) {\n    // @ts-ignore TS being overprotective, HoverGestureHandlerEventPayload is Record\n    this.handlers.changeEventCalculator = changeEventCalculator;\n    return super.onChange(callback);\n  }\n}\n\nexport type HoverGestureType = InstanceType<typeof HoverGesture>;\n"],"mappings":";;;;;;;;;;;;;;;AAAA,IAAAA,QAAA,GAAAC,OAAA;;;;;;;;;;;;;;IAeYC,W;;WAAAA,W;EAAAA,W,CAAAA,W;EAAAA,W,CAAAA,W;EAAAA,W,CAAAA,W;GAAAA,W,2BAAAA,W;AAUL,IAAMC,wBAAwB,GAAG,CAAC,aAAD,CAAjC;;AAEP,SAASC,qBAATA,CACEC,OADF,EAEEC,QAFF,EAGE;EACA;;EACA,IAAIC,aAAJ;EACA,IAAID,QAAQ,KAAKE,SAAjB,EAA4B;IAC1BD,aAAa,GAAG;MACdE,OAAO,EAAEJ,OAAO,CAACK,CADH;MAEdC,OAAO,EAAEN,OAAO,CAACO;IAFH,CAAhB;EAID,CALD,MAKO;IACLL,aAAa,GAAG;MACdE,OAAO,EAAEJ,OAAO,CAACK,CAAR,GAAYJ,QAAQ,CAACI,CADhB;MAEdC,OAAO,EAAEN,OAAO,CAACO,CAAR,GAAYN,QAAQ,CAACM;IAFhB,CAAhB;EAID;EAED,OAAAC,MAAA,CAAAC,MAAA,KAAYT,OAAL,EAAiBE,aAAA;AACzB;AAAA,IAEYQ,YAAN,aAAAC,qBAAA;EAML,SAAAD,aAAA,EAAc;IAAA,IAAAE,KAAA;IAAA,IAAAC,gBAAA,CAAAC,OAAA,QAAAJ,YAAA;IACZE,KAAA,GAAAG,UAAA,OAAAL,YAAA;IADYM,eAAA,CAAAJ,KAAA,YAF0C,EAE1C;IAGZA,KAAA,CAAKK,WAAL,GAAmB,qBAAnB;IAAA,OAAAL,KAAA;EACD;EAAA,IAAAM,UAAA,CAAAJ,OAAA,EAAAJ,YAAA,EAAAC,qBAAA;EAAA,WAAAQ,aAAA,CAAAL,OAAA,EAAAJ,YAAA;IAAAU,GAAA;IAAAC,KAAA,EAMD,SAAAC,OAAOA,OAAD,EAAsB;MAC1B,KAAKC,MAAL,CAAYC,WAAZ,GAA0BF,OAA1B;MACA,OAAO,IAAP;IACD;EAAA;IAAAF,GAAA;IAAAC,KAAA,EAED,SAAAI,SACEC,QADM,EAMN;MAEA,KAAKC,QAAL,CAAc5B,qBAAd,GAAsCA,qBAAtC;MACA,WAAA6B,KAAA,CAAAd,OAAA,MAAAe,gBAAA,CAAAf,OAAA,EAAAJ,YAAA,CAAAoB,SAAA,qBAAAC,IAAA,OAAsBL,QAAf;IACR;EAAA;AAAA,EA/B+B/B,QAAA,CAAAqC,oBAA3B","ignoreList":[]}